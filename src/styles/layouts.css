/* === NUDS Layouts === */
/* -------- BOX ------------ */
@custom-selector :--box-l .box, :--box;
@custom-selector :--no-border-l .no-border, :--no-border;
/*
--padding-box: var dimension (fallback to --padding OR --gap/2 OR 0.5em)
--border-width-box: var dimension (fallback to --border-width OR --size-border OR 1px)
REMOVED ~~color-light~~
REMOVED ~~color-dark~~
*/
:--box-l {
  display: block;
  --padding-box: var(--padding, calc(var(--gap, 1em) / 2));
  --border-width-box: var(--border-width, var(--size-border, 1px));
  padding: var(--padding-box);
  border: var(--border-width-box) solid;
}
:--box-l:--no-border-l {
  border: none;
  /* For high contrast mode if no border */
  outline: var(--border-width-box) solid transparent;
  outline-offset: calc(var(--border-width-box) * -1);
}

/* -------- STACK ------------ */
/* TODO: custom selectors do not work if we want to assign a main layout AND modifiers. Ex render: bodybody instead of .stack.recursive*/
@custom-selector :--stack-l .stack, :--stack;
@custom-selector :--horizontal-l .horizontal, :--horizontal;
@custom-selector :--recursive-l .recursive, :--recursive;
@custom-selector :--split-after-me-l .split-after-me, :--split-after-me;
/*
--gap-stack: var dimension (fallback to --gap OR 1em)
.recursive: class bool
.split-after-[x]: class -> x = int (0 < x < 6)
NEW: .split-after-me: class -> to specify after which element we want to split
NEW: .horizontal: class bool
NEW: .stop: class bool -> apply `class="stack recursive stop"` to stop recursion down this path
*/
:--stack-l {
  --gap-stack: var(--gap, 1em);
  display: flex;
  flex-direction: column;
  justify-content: flex-start;
}
:--stack-l:not(:--horizontal-l) > *,
:--stack-l:--recursive-l:not(:--horizontal-l) * {
  margin-block: 0;
}
:--stack-l:not(:--horizontal-l) > * + *,
:--stack-l:--recursive-l:not(:--horizontal-l) * + * {
  margin-block-start: var(--gap-stack);
}
:--stack-l:not(:--horizontal-l):only-child {
  block-size: 100%;
}
/* horizontal mod */
:--stack-l:--horizontal-l {
  flex-direction: row;
  align-items: center;
}
:--stack-l:--horizontal-l > *,
:--stack-l:--horizontal-l:--recursive-l * {
  margin-inline: 0;
}
:--stack-l:--horizontal-l > * + *,
:--stack-l:--horizontal-l:--recursive-l * + * {
  margin-inline-start: var(--gap-stack);
}
:--stack-l:--horizontal-l:only-child {
  inline-size: 100%;
}
/* split-after */ /* prettier-ignore */
:--stack-l:not(:--horizontal-l) > :--split-after-me-l { margin-block-end: auto; } /* prettier-ignore */
:--stack-l:--horizontal-l > :--split-after-me-l { margin-inline-end: auto; } /* prettier-ignore */
:--stack-l:not(:--horizontal-l).split-after-1 > :nth-child(1) { margin-block-end: auto; } /* prettier-ignore */
:--stack-l:--horizontal-l.split-after-1 > :nth-child(1) { margin-inline-end: auto; } /* prettier-ignore */
:--stack-l:not(:--horizontal-l).split-after-2 > :nth-child(2) { margin-block-end: auto; } /* prettier-ignore */
:--stack-l:--horizontal-l.split-after-2 > :nth-child(2) { margin-inline-end: auto; } /* prettier-ignore */
:--stack-l:not(:--horizontal-l).split-after-3 > :nth-child(3) { margin-block-end: auto; } /* prettier-ignore */
:--stack-l:--horizontal-l.split-after-3 > :nth-child(3) { margin-inline-end: auto; } /* prettier-ignore */
:--stack-l:not(:--horizontal-l).split-after-4 > :nth-child(4) { margin-block-end: auto; } /* prettier-ignore */
:--stack-l:--horizontal-l.split-after-4 > :nth-child(4) { margin-inline-end: auto; } /* prettier-ignore */
:--stack-l:not(:--horizontal-l).split-after-5 > :nth-child(5) { margin-block-end: auto; } /* prettier-ignore */
:--stack-l:--horizontal-l.split-after-5 > :nth-child(5) { margin-inline-end: auto; } /* prettier-ignore */
/* --- ... --- */

:--stack-l:not(:--horizontal-l):--recursive-l.stop * + *,
:--stack-l:--horizontal-l:--recursive-l.stop * + * {
  margin-block-start: 0;
  margin-inline-start: 0;
}

/* -------- CENTER ------------ */
@custom-selector :--center-l .center, :--center;
@custom-selector :--text-l .text, :--text;
@custom-selector :--intrinsic-l .intrinsic, :--intrinsic;
/*
--max-width: var dimension (fallback to --width-max OR --measure OR 60ch)
.text: class bool
--gutters-center: var dimension (fallback to --padding OR --gap/2 OR 0.5em)
.intrinsic: class bool
*/
:--center-l {
  --gutters-center: var(--padding, calc(var(--gap, 1em) / 2));
  display: block;
  box-sizing: content-box;
  margin-inline: auto;
  max-inline-size: var(--max-width, var(--width-max, var(--measure, 60ch)));
  padding-inline: var(--gutters-center);
}
:--center-l:--text-l {
  text-align: center;
}
:--center-l:--intrinsic-l {
  display: flex;
  flex-direction: column;
  align-items: center;
}
/* :--center-l.max {
  inline-size: 100%;

  width: var(--max-width, var(--width-max, var(--measure, 60ch)));
  max-width: 100%;
} */

/* -------- CLUSTER ------------ */
@custom-selector :--cluster-l .cluster, :--cluster;
/*
--gap-cluster: var dimension (fallback to --gap OR 1em)
--justify-cluster: var keyword -> for horizontal alignment (fallback to flex-start)
--align-cluster: var keyword -> for vertical alignment (fallback to center)
*/
:--cluster-l {
  --gap-cluster: var(--gap, 1em);
  --justify-cluster: flex-start;
  --align-cluster: center;
  display: flex;
  flex-wrap: wrap;
  gap: var(--gap-cluster);
  justify-content: var(--justify-cluster);
  align-items: var(--align-cluster);
}

/* TODO: Are focus styles OK ??? */
/* focus style is hidden if we don't allow overflow */
/* we can use this if there are outer margins to our cluster > than the inner margins between elements */
/* TODO: we could try and find a better way to know if we can overflew */
/* .cluster:not(.overflow) *:focus {
  outline: 1px solid;
  outline-offset: -1px;
} */

/* TODO: Can we split this? */
/* Does not work */
/* .cluster.split-after-1 > * > :nth-child(1) { margin-right: auto; } /* prettier-ignore */

/* -------- WITH SIDEBAR ------------ */
@custom-selector :--with-sidebar-l .with-sidebar, :--with-sidebar;
@custom-selector :--right-l .right, :--right;
/*
--gap-sidebar: var dimension (fallback to --gap OR 1em)
--width-sidebar: var dimension | The width of the sidebar (empty means not set; defaults to the content width)
--content-min: var dimension(%) = 50% | The narrowest the content (main) element can be before wrapping. Should be a percentage.
.right: class bool | Whether the sidebar element is the :last-child or :first-child
*/
/* TODO: Find method to change order of element when they wrap 
-> ?? can we use dir: rtl; to swap the order of elements when they wrap?? */
:--with-sidebar-l {
  --gap-sidebar: var(--gap, 1em);
  display: flex;
  flex-wrap: wrap;
  gap: var(--gap-sidebar);
}
:--with-sidebar-l:not(:--right-l) > :first-child,
:--with-sidebar-l:--right-l > :last-child {
  flex-basis: var(--width-sidebar);
  flex-grow: 1;
}
:--with-sidebar-l:not(:--right-l) > :last-child,
:--with-sidebar-l:--right-l > :first-child {
  flex-basis: 0;
  flex-grow: 999;
  min-inline-size: var(--content-min, 50%);
}

/* -------- SWITCHER ------------ */
@custom-selector :--switcher-l .switcher, :--switcher;
/*
--gap-switcher: var dimension | The space (margin) between the (child) elements (fallback to --gap OR 1em)
--width-wrap: var dimension | The container width at which the component switches between a horizontal and vertical layout
.limit-[x]: class -> x = int (1 < x < 9) | The maximum number of elements allowed to appear in the horizontal configuration
*/
:--switcher-l {
  --gap-switcher: var(--gap, 1em);
  display: flex;
  flex-wrap: wrap;
  gap: var(--gap-switcher);
}
:--switcher-l > * {
  flex-grow: 1;
  /* TODO: is 30rem a good default? */
  flex-basis: calc((var(--width-wrap, 30rem) - 100%) * 999);
  /* MOD IN V1: do I need to care about the gap?I guess not but... */
  /* flex-basis: calc(
    (var(--container-wrap, 20rem) - (100% - var(--gap))) * 999
  ); */
}
/* prettier-ignore */
:--switcher-l.limit-2 > :nth-last-child(n+3), :--switcher-l.limit-2 > :nth-last-child(n+3) ~ * { flex-basis: 100%; } /* prettier-ignore */
:--switcher-l.limit-3 > :nth-last-child(n+4), :--switcher-l.limit-3 > :nth-last-child(n+4) ~ * { flex-basis: 100%; } /* prettier-ignore */
:--switcher-l.limit-4 > :nth-last-child(n+5), :--switcher-l.limit-4 > :nth-last-child(n+5) ~ * { flex-basis: 100%; } /* prettier-ignore */
:--switcher-l.limit-5 > :nth-last-child(n+6), :--switcher-l.limit-5 > :nth-last-child(n+6) ~ * { flex-basis: 100%; } /* prettier-ignore */
:--switcher-l.limit-6 > :nth-last-child(n+7), :--switcher-l.limit-6 > :nth-last-child(n+7) ~ * { flex-basis: 100%; } /* prettier-ignore */
:--switcher-l.limit-7 > :nth-last-child(n+8), :--switcher-l.limit-7 > :nth-last-child(n+8) ~ * { flex-basis: 100%; } /* prettier-ignore */
:--switcher-l.limit-8 > :nth-last-child(n+9), :--switcher-l.limit-8 > :nth-last-child(n+9) ~ * { flex-basis: 100%; } /* prettier-ignore */

/* -------- COVER ------------ */
@custom-selector :--cover-l .cover, :--cover;
@custom-selector :--no-padding-l .no-padding, :--no-padding;
@custom-selector :--centered-l .centered, :--centered;
/*
--gap-cover: var dimension | The minimum space between and around the child elements
--min-height-cover: var dimension (100vh) | The minimum height of the parent element, before it grows to accommodate its content
.no-padding: class bool  (false) | Whether to remove the padding from the parent element
NEW: .centered | place a ".centered" class on the child that needs centering
*/
:--cover-l {
  --gap-cover: var(--gap, 1em);
  display: flex;
  flex-direction: column;
  min-block-size: var(--min-height-cover, 100vh);
  padding: var(--gap-cover);
}
:--cover-l:--no-padding-l {
  padding: 0;
}
:--cover-l > * {
  margin-block: var(--gap-cover);
}
:--cover-l > :first-child:not(:--centered-l) {
  margin-block-start: 0;
}
:--cover-l > :last-child:not(:--centered-l) {
  margin-block-end: 0;
}
:--cover-l > :--centered-l {
  margin-block: auto;
}
/* TODO: do this with a mixin and/or function if we need it */ /*
.cover.center-h1 > :first-child:not(h1) { margin-block-start: 0; } .cover.center-h1 > :last-child:not(h1) { margin-block-end: 0; } .cover.center-h1 > h1 { margin-block: auto; }
.cover.center-h2 > :first-child:not(h2) { margin-block-start: 0; } .cover.center-h2 > :last-child:not(h2) { margin-block-end: 0; } .cover.center-h2 > h2 { margin-block: auto; }
*/

/* -------- GRID ------------ */
@custom-selector :--grid-l .grid, :--grid;
/* 
--gap-grid: var dimension | The space (margin) between the (child) elements (fallback to --gap OR 1em)
--width-column-min: var dimension -> minimum col width (or flex-basis if in flex mode)
*/
:--grid-l {
  --gap-grid: var(--gap, 1em);
  display: grid;
  grid-gap: var(--gap-grid);
}
/* TODO: What is a good default? Every Layout's website set 250px by default. I had 10rem in V1. */
/* @supports (width: min(var(--width-column-min, 250px), 100%)) { */
@supports (width: min(var(--width-column-min, 10rem), 100%)) {
  :--grid-l {
    /* grid-template-columns: repeat(auto-fit, minmax(min(var(--width-column-min, 250px), 100%), 1fr)); */
    grid-template-columns: repeat(
      auto-fit,
      minmax(min(var(--width-column-min, 10rem), 100%), 1fr)
    );
  }
}

/* -------- FRAME ------------ */
/* TODO HERE */
@custom-selector :--frame-l .frame, :--frame;
@custom-selector :--frame-inner-l .frame-inner, img, video, :--frame-inner;
/*
--n: var int -> numerator
--d: var int -> denominator
NEW: --aspect-ratio: var number or fraction (16/9) | The element's aspect ratio
NEW: --object-fit-frame: var keyword
*/

:--frame-l {
  --n: 16;
  --d: 9;
  aspect-ratio: var(--n) / var(--d);
  /* TODO: check if this var notation works on all browsers */
  aspect-ratio: var(--aspect-ratio, var(--n) / var(--d));
  overflow: hidden;
  display: flex;
  justify-content: center;
  align-items: center;
}
:--frame-l > :--frame-inner-l {
  inline-size: 100%;
  block-size: 100%;
  object-fit: var(--object-fit-frame, cover);
}

/* -------- REEL ------------ */
@custom-selector :--reel-l .reel, :--reel;
@custom-selector :--overflowing-l .overflowing, :--overflowing;
@custom-selector :--no-bar-l .no-bar, :--no-bar;
@custom-selector :--no-js-l .no-js, :--no-js;
/*
--item-width: var dimension or keyword (auto) | The width of each child element
--height: var dimension or keyword (auto) | The height of the parent (Reel) element
--gap-reel: var dimension | The space between each child element, and between the child elements and the scrollbar
NEW: .no-bar: class bool (false), // Whether to display the scrollbar
--track-color: var color (currentcolor)
--thumb-color: var color (white)
NEW: .no-js: class bool (false) | Wether the observer has been setup to manage the "overflowing" classname
*/
/* TODO: ? Javascript observer for scrollbar ? Can we avoid it? */
/* TODO: ? implement background attachment local for affordance instead. http://lea.verou.me/2012/04/background-attachment-local/ */
/* TODO: ? should --thumb-color have a fallback? */

:--reel-l {
  --gap-reel: var(--gap, 1em);
  display: flex;
  block-size: var(--height, auto);
  overflow-x: auto;
  overflow-y: hidden;
  scrollbar-color: var(--thumb-color) var(--track-color, currentcolor);
}
/* NEW */
:--reel-l:--no-bar-l {
  scrollbar-width: none;
}
:--reel-l > * {
  flex: 0 0 var(--item-width, auto);
}
/* TODO: decide if we expand this selector */
/* :--reel-l > .img,
:--reel-l > .image, */
:--reel-l > img {
  block-size: 100%;
  flex-basis: auto;
  /* ?? Shouldn't it be inline-size: auto; */
  width: auto;
}
:--reel-l > * + * {
  margin-inline-start: var(--gap-reel);
}
:--reel-l:--overflowing-l:not(:--no-bar-l),
:--reel-l:--no-js-l:not(:--no-bar-l) {
  padding-block-end: var(--gap-reel);
}
/* TODO: NEW -> part of nuds-colors. should we set defaults and override in nuds-colors? */
:--reel-l::-webkit-scrollbar {
  block-size: 1rem; /* NOTE: shouldn't it be --gap-reel instead ? */
}
/* NEW */
:--reel-l:--no-bar-l::-webkit-scrollbar {
  display: none;
}
:--reel-l::-webkit-scrollbar-track {
  background-color: var(--track-color, currentcolor);
}
:--reel-l::-webkit-scrollbar-thumb {
  background-color: var(--track-color, currentcolor);
  background-image: linear-gradient(
    var(--track-color, currentcolor) 0,
    var(--track-color, currentcolor) 0.25rem,
    var(--thumb-color) 0.25rem,
    var(--thumb-color) 0.75rem,
    var(--track-color, currentcolor) 0.75rem
  );
}

/* -------- IMPOSTER ------------ */
@custom-selector :--imposter-l .imposter, :--imposter;
@custom-selector :--fixed-l .fixed, :--fixed;
@custom-selector :--breakout-l .breakout, :--breakout;
/* 
--margin-imposter: var dimension
.fixed: class bool | to position the imposter relatve to the viewport
NEW: --position-imposter: var keyword | alternative positionning. overrides the .fixed class
.breakout: class bool | Whether the element is allowed to break out of the container over which it is positioned
*/
:--imposter-l {
  display: block;
  position: var(--position-imposter, absolute);
  inset-block-start: 50%;
  inset-inline-start: 50%;
  transform: translate(-50%, -50%);
}
:--imposter-l:not(:--breakout-l) {
  --margin-imposter: 0px;
  overflow: auto;
  max-inline-size: calc(100% - (var(--margin-imposter) * 2));
  max-block-size: calc(100% - (var(--margin-imposter) * 2));
}
:--imposter-l:--fixed-l {
  position: var(--position-imposter, fixed);
}

/* -------- ICON ------------ */
@custom-selector :--icon-l .icon, :--icon;
@custom-selector :--lowercase-l .lowercase, :--lowercase;
@custom-selector :--with-icon-l .with-icon, :--with-icon;
@custom-selector :--right-l .right, :--right;
@custom-selector :--super-l .super, :--super;
@custom-selector :--sub-l .sub, :--sub;
/* 
--width-icon: var length
--height-icon: var length
--vertical-align-icon: var keyword OR length | length -> in case we want to make a large icon and center it manually
.lowercase: class bool | place it on icon fo icon only OR on .with-icon to force lowercase text
.right: class bool | reverse margin for icon on the right
.super: class bool
.sub: class bool
REMARK: .icon can be used alone if we don't need to control over space between icon and text
*/
:--icon-l {
  /* Usually 0.75em more closely matches uppercase letter height */
  width: var(--width-icon, 0.75em);
  /* 1cap = nominal height of capital letters of the element's font */
  width: var(--width-icon, 1cap);
  height: var(--height-icon, 0.75em);
  height: var(--height-icon, 1cap);
  vertical-align: var(--vertical-align-icon, baseline);
}
:--icon-l:--lowercase-l,
:--lowercase-l > :--icon-l {
  /* TODO: ?is this a good default? */
  width: var(--width-icon, 0.6em);
  /* matches lowercase height of "x" */
  width: var(--width-icon, 1ex);
  height: var(--height-icon, 0.6em);
  height: var(--height-icon, 1ex);
}
:--icon-l:--sub-l,
:--icon-l:--super-l,
:--super-l > :--icon-l,
:--sub-l > :--icon-l {
  /* TODO: ?is this a good default? */
  width: var(--width-icon, 0.25em);
  height: var(--height-icon, 0.25em);
}
:--icon-l:--sub-l,
:--sub-l > :--icon-l {
  vertical-align: var(--vertical-align-icon, sub);
}
:--icon-l:--super-l,
:--super-l > :--icon-l {
  vertical-align: var(--vertical-align-icon, super);
}
:--with-icon-l {
  display: inline-flex;
  align-items: baseline;
}
:--with-icon-l:--lowercase-l {
  text-transform: lowercase;
}
:--with-icon-l:not(:--right-l) :--icon-l {
  margin-inline-end: var(--gap-icon, 1rem);
  margin-inline-end: var(--gap-icon, 1ch);
}
:--with-icon-l:--right-l :--icon-l {
  margin-inline-start: var(--gap-icon, 1rem);
  margin-inline-start: var(--gap-icon, 1ch);
}
/* NOTE: use it like so */
/* IMPORTANT to set width and height on the svg in case CSS fails to load */
/* 
<span class="with-icon">
  <svg class="icon" width="0.75em" height="0.75em">
    <use href="/path/to/icons.svg#my-icon"></use>
  </svg>
  Close
</span>
OR if there is no text -> ?? role and aria-label on svg or span ??
<span class="with-icon" role="img" aria-label="{label}">
  <svg class="icon" width="0.75em" height="0.75em">
    <use href="/path/to/icons.svg#my-icon"></use>
  </svg>
</span>
*/

/* -------- UTILITY-HELPERS ------------ */
/* because ppl seem to like "functional css" */
/* .justify-stretch, .justify-content-stretch { --justify-content: stretch; }
.justify-center, .justify-content-center { --justify-content: center; }
.justify-start, .justify-content-start { --justify-content: flex-start; }
.justify-end, .justify-content-end { --justify-content: flex-end; }
.justify-space-between, .justify-content-space-between { --justify-content: space-between; }
.justify-space-around, .justify-content-space-around { --justify-content: space-around; }
.justify-space-evenly, .justify-content-space-evenly { --justify-content: space-around; justify-content: space-evenly; }
.align-items-stretch { --align-items: stretch; }
.align-items-center { --align-items: center; }
.align-items-start { --align-items: flex-start; }
.align-items-end { --align-items: flex-end; }
.align-content-baseline { --align-content: baseline; }
.align-content-center { --align-content: center; }
.align-content-start { --align-content: flex-start; }
.align-content-end { --align-content: flex-end; }
.align-content-space-between { --align-content: space-between; }
.align-content-space-around { --align-content: space-around; }
.align-content-space-evenly { --align-content: space-around; align-content: space-evenly; }
.align-content-stretch { --align-content: stretch; } */
